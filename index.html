<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Peyote ULTRA-SAFE v3.6.2</title>
<style>
  body{margin:0;font-family:ui-sans-serif,system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;background:#f1f5f9;color:#0f172a}
  header{background:#fff;border-bottom:3px solid #ef4444;padding:12px 16px}
  .banner{background:#fee2e2;color:#991b1b;padding:6px 10px;border:1px solid #fecaca;border-radius:6px;display:inline-block}
  .badge{font-size:12px;font-weight:700;padding:2px 6px;border:1px solid #e5e7eb;border-radius:6px;background:#f3f4f6;color:#111;margin-left:8px}
  main{display:flex;flex-direction:column;gap:12px;padding:12px 16px}
  section{background:#fff;border:1px solid #e5e7eb;border-radius:8px;overflow:hidden}
  #statusPanel{padding:10px 16px}
  #controls{padding:12px;display:flex;flex-wrap:wrap;gap:12px;align-items:center}
  #origPreview{max-width:100%;border:1px solid #e5e7eb;background:#f8fafc}
  #cropThumb,#loupe,#beadSim{border:1px solid #e5e7eb;background:#f8fafc;max-width:100%}
  #cropCanvas{border:2px solid #e5e7eb;background:#fff;width:600px;height:360px;touch-action:pan-y pinch-zoom}
  button{padding:6px 10px;border:1px solid #d1d5db;background:#f3f4f6;border-radius:6px;cursor:pointer}
  .row{display:flex;gap:16px;flex-wrap:wrap;padding:12px}
  .col{flex:1;min-width:260px}
  .small{font-size:12px;color:#475569}
  #assistRow{display:flex;gap:16px;flex-wrap:wrap;padding:12px}
  #debugOut{white-space:pre-wrap;margin:8px 0 0 0; font-size:12px; color:#111; background:#f9fafb; border:1px solid #e5e7eb; padding:8px; border-radius:6px; max-height:260px; overflow:auto}
</style>
</head>
<body>
<header>
  <div class="banner">JavaScript running ✔ ULTRA-SAFE v3.6.2</div>
  <span class="badge">inline single-file</span>
</header>

<section id="statusPanel">
  <div style="font-weight:600">Status</div>
  <div id="statusLog" class="small" style="white-space:pre-line;color:#374151">Ready.</div>
</section>

<main>
  <section id="controls">
    <input id="file" type="file" accept="image/jpeg,image/png,image/webp,image/*;capture=environment">
    <button id="btnLoadTest">Load Test Image</button>
    <button id="btnResetCrop">Reset Crop</button>
    <label class="small"><input type="checkbox" id="lockCropAspect" checked> Lock crop to bead aspect</label>
    <span id="cropAspectLabel" class="small"></span>
    <label class="small">Bead W: <input id="beadW" type="number" value="90" min="10" max="400"></label>
    <label class="small">Bead H: <input id="beadH" type="number" value="50" min="10" max="400"></label>
  </section>

  <section id="previewPane">
    <div class="row">
      <div class="col">
        <div class="small">Original</div>
        <img id="origPreview" alt="original">
        <div id="fileInfo" class="small">–</div>
      </div>
      <div class="col">
        <div class="small">Crop</div>
        <canvas id="cropThumb" width="240" height="160"></canvas>
      </div>
    </div>
  </section>

  <section id="assist">
    <h3 style="margin:12px">Assist Previews</h3>
    <div id="assistRow">
      <div>
        <div class="small">Zoom (loupe)</div>
        <canvas id="loupe" width="140" height="140"></canvas>
      </div>
      <div>
        <div class="small">Bead view</div>
        <canvas id="beadSim" width="260" height="180"></canvas>
      </div>
    </div>
  </section>

  <section id="cropper" style="padding:12px">
    <canvas id="cropCanvas" width="600" height="360"></canvas>
  </section>
</main>

<section id="debugPanel" style="padding:12px 16px;background:#fff;border-top:1px solid #e5e7eb">
  <div style="display:flex;align-items:center;justify-content:space-between;gap:8px;">
    <h3 style="margin:0">Debug Data</h3>
    <button id="btnCopyDebug">Copy</button>
  </div>
  <pre id="debugOut"></pre>
</section>

<script>
// ---- Status & Debug ----
const statusEl = document.getElementById('statusLog');
function logStatus(msg){ const t=new Date().toLocaleTimeString(); statusEl.textContent += "\\n["+t+"] "+msg; }
window.addEventListener('error', e=>{ logStatus("JS error: "+(e.message||e.error)); });
window.addEventListener('unhandledrejection', e=>{ logStatus("Promise rejection: "+(e.reason&&e.reason.message?e.reason.message:e.reason)); });

const debugEl = document.getElementById('debugOut');
const copyBtn = document.getElementById('btnCopyDebug');
let debugState = {
  loader:'—', file:{name:'—',type:'—',size:0}, image:{w:0,h:0,ar:0},
  drew:{orig:false,crop:false,bead:false},
  device:{dpr:window.devicePixelRatio||1, ua:navigator.userAgent},
  touch:{x:null,y:null}
};
function upd(){ const f=debugState.file,i=debugState.image,t=debugState.touch;
  const sz = f.size ? (f.size>=1e6?(f.size/1e6).toFixed(2)+' MB':(f.size/1e3).toFixed(1)+' KB'):'0';
  debugEl.textContent = [
    "Loader: "+debugState.loader,
    "File: "+f.name+" ("+f.type+", "+sz+")",
    "Image: "+i.w+"×"+i.h+" (AR "+(i.ar||0).toFixed(3)+")",
    "Drawn → Original:"+(debugState.drew.orig?'✅':'—')+"  Crop:"+(debugState.drew.crop?'✅':'—')+"  Bead:"+(debugState.drew.bead?'✅':'—'),
    "devicePixelRatio: "+debugState.device.dpr,
    "Touch last: "+(t.x!=null?("("+Math.round(t.x)+", "+Math.round(t.y)+")"):'—')
  ].join("\\n");
}
function setLoader(x){ debugState.loader=x; upd(); }
function setFile(f){ if(!f) return; debugState.file={name:f.name||'—',type:f.type||'—',size:f.size||0}; upd(); }
function setImage(img){ if(!img) return; debugState.image={w:img.width||0,h:img.height||0,ar: img.width?img.width/img.height:0}; upd(); }
function markDraw(k,v){ debugState.drew[k]=!!v; upd(); }
function setTouch(x,y){ debugState.touch={x,y}; upd(); }
upd();
copyBtn.addEventListener('click', ()=>{
  const txt = debugEl.textContent || '';
  if (navigator.clipboard && navigator.clipboard.writeText){
    navigator.clipboard.writeText(txt).then(()=>{ copyBtn.textContent='Copied!'; setTimeout(()=>copyBtn.textContent='Copy',1200);} );
  } else {
    const r=document.createRange(); r.selectNodeContents(debugEl);
    const s=window.getSelection(); s.removeAllRanges(); s.addRange(r);
    try{ document.execCommand('copy'); copyBtn.textContent='Copied!'; setTimeout(()=>copyBtn.textContent='Copy',1200);}catch(_){}
  }
});

// ---- Elements ----
const els = {
  file: document.getElementById('file'),
  btnLoadTest: document.getElementById('btnLoadTest'),
  btnResetCrop: document.getElementById('btnResetCrop'),
  lockCropAspect: document.getElementById('lockCropAspect'),
  cropAspectLabel: document.getElementById('cropAspectLabel'),
  beadW: document.getElementById('beadW'),
  beadH: document.getElementById('beadH'),
  origPreview: document.getElementById('origPreview'),
  fileInfo: document.getElementById('fileInfo'),
  cropThumb: document.getElementById('cropThumb'),
  loupe: document.getElementById('loupe'),
  beadSim: document.getElementById('beadSim'),
  cropCanvas: document.getElementById('cropCanvas')
};
const cropCtx = els.cropCanvas.getContext('2d', {willReadFrequently:true});
const cropThumbCtx = els.cropThumb.getContext('2d', {willReadFrequently:true});
const loupeCtx = els.loupe.getContext('2d', {willReadFrequently:true});
const beadSimCtx = els.beadSim.getContext('2d', {willReadFrequently:true});

// ---- Image Loading ----
function loadImage(url){
  return new Promise((res,rej)=>{ const img=new Image(); img.onload=()=>res(img); img.onerror=()=>rej(new Error('Image load failed')); img.src=url; });
}
async function robustLoadFile(file){
  if (!file) throw new Error("No file");
  const name = (file.name||'').toLowerCase();
  if (name.endsWith('.heic') || name.endsWith('.heif')){
    logStatus("HEIC/HEIF detected; if this fails, screenshot the photo (PNG) or export JPEG.");
  }
  try{
    if ('createImageBitmap' in window){
      setLoader('createImageBitmap'); logStatus("Trying createImageBitmap...");
      const bmp = await createImageBitmap(file);
      const can=document.createElement('canvas');
      const maxDim=2400; const sc=Math.min(1, maxDim/Math.max(bmp.width,bmp.height));
      can.width=Math.max(1,Math.round(bmp.width*sc)); can.height=Math.max(1,Math.round(bmp.height*sc));
      const c=can.getContext('2d'); c.drawImage(bmp,0,0,can.width,can.height);
      const url=can.toDataURL('image/jpeg',0.92);
      const img=await loadImage(url);
      return {img,url};
    }
  }catch(e){ logStatus("createImageBitmap failed"); }
  try{
    setLoader('FileReader'); logStatus("Trying FileReader...");
    const dataURL = await new Promise((res,rej)=>{ const r=new FileReader(); r.onload=()=>res(r.result); r.onerror=()=>rej(new Error('FileReader failed')); r.readAsDataURL(file); });
    const img = await loadImage(dataURL);
    return {img,url:dataURL};
  }catch(e){ logStatus("FileReader failed"); }
  try{
    setLoader('BlobURL'); logStatus("Trying Blob URL...");
    const blobURL = URL.createObjectURL(file);
    const img = await loadImage(blobURL);
    return {img,url:blobURL};
  }catch(e){ logStatus("Blob URL failed"); }
  throw new Error("All loaders failed");
}

// ---- Crop & Preview ----
let sourceImg=null, cropImg=null, viewScale=1;
let crop={x:80,y:40,w:440,h:280};
let isDragging=false, dragMode=null, dragOX=0, dragOY=0;
let lastPointer=null;

function getCanvasPos(e){
  const rect = els.cropCanvas.getBoundingClientRect();
  const sx = els.cropCanvas.width / rect.width;
  const sy = els.cropCanvas.height / rect.height;
  const mx = (e.clientX - rect.left) * sx;
  const my = (e.clientY - rect.top) * sy;
  return {mx,my};
}
function handlePoints(){
  const midX=crop.x+crop.w/2, midY=crop.y+crop.h/2;
  return [
    {name:'nw',x:crop.x,y:crop.y},{name:'ne',x:crop.x+crop.w,y:crop.y},
    {name:'sw',x:crop.x,y:crop.y+crop.h},{name:'se',x:crop.x+crop.w,y:crop.y+crop.h},
    {name:'n',x:midX,y:crop.y},{name:'s',x:midX,y:crop.y+crop.h},
    {name:'w',x:crop.x,y:midY},{name:'e',x:crop.x+crop.w,y:midY}
  ];
}
function hitHandle(mx,my){
  const r=22,b=20;
  const cs=[{n:'nw',x:crop.x,y:crop.y},{n:'ne',x:crop.x+crop.w,y:crop.y},{n:'sw',x:crop.x,y:crop.y+crop.h},{n:'se',x:crop.x+crop.w,y:crop.y+crop.h}];
  for(const c of cs){ const dx=mx-c.x,dy=my-c.y; if (dx*dx+dy*dy<=r*r) return c.n; }
  if (my>=crop.y+b && my<=crop.y+crop.h-b){ if (Math.abs(mx-crop.x)<=b) return 'w'; if (Math.abs(mx-(crop.x+crop.w))<=b) return 'e'; }
  if (mx>=crop.x+b && mx<=crop.x+crop.w-b){ if (Math.abs(my-crop.y)<=b) return 'n'; if (Math.abs(my-(crop.y+crop.h))<=b) return 's'; }
  return null;
}
function drawCropper(){
  markDraw('crop', !!cropImg);
  const ctx=cropCtx;
  ctx.clearRect(0,0,els.cropCanvas.width,els.cropCanvas.height);
  if (!cropImg) return;
  const s = Math.min(els.cropCanvas.width/cropImg.width, els.cropCanvas.height/cropImg.height);
  viewScale=s;
  const vw=cropImg.width*s, vh=cropImg.height*s;
  const offX=Math.floor((els.cropCanvas.width - vw)/2), offY=Math.floor((els.cropCanvas.height - vh)/2);
  els.cropCanvas._offX=offX; els.cropCanvas._offY=offY;
  ctx.drawImage(cropImg,0,0,cropImg.width,cropImg.height, offX,offY, vw,vh);
  ctx.save(); ctx.fillStyle="rgba(0,0,0,0.35)"; ctx.beginPath();
  ctx.rect(0,0,els.cropCanvas.width,els.cropCanvas.height); ctx.rect(crop.x,crop.y,crop.w,crop.h); ctx.fill("evenodd"); ctx.restore();
  ctx.strokeStyle="#22c55e"; ctx.lineWidth=2; ctx.strokeRect(crop.x+0.5,crop.y+0.5,crop.w,crop.h);
  const hs=handlePoints(); ctx.fillStyle="#22c55e";
  hs.forEach(p=>{ ctx.beginPath(); ctx.arc(p.x,p.y,9,0,Math.PI*2); ctx.fill(); ctx.strokeStyle="#15803d"; ctx.stroke(); });
  updateCropThumb();
}
function cropRegion(){
  const offX=els.cropCanvas._offX||0, offY=els.cropCanvas._offY||0;
  const sx=Math.max(0,Math.round((crop.x-offX)/viewScale));
  const sy=Math.max(0,Math.round((crop.y-offY)/viewScale));
  const sw=Math.max(1,Math.round(crop.w/viewScale));
  const sh=Math.max(1,Math.round(crop.h/viewScale));
  return {sx,sy,sw,sh};
}
function updateCropThumb(){
  if (!cropImg) return;
  const {sx,sy,sw,sh}=cropRegion();
  const tw=els.cropThumb.width, th=els.cropThumb.height;
  cropThumbCtx.clearRect(0,0,tw,th);
  cropThumbCtx.fillStyle="#f8fafc"; cropThumbCtx.fillRect(0,0,tw,th);
  const sc=Math.min(tw/sw, th/sh);
  const dw=Math.max(1,Math.round(sw*sc)), dh=Math.max(1,Math.round(sh*sc));
  const dx=Math.floor((tw-dw)/2), dy=Math.floor((th-dh)/2);
  cropThumbCtx.drawImage(cropImg, sx,sy,sw,sh, dx,dy, dw,dh);
  // Loupe
  const lW=els.loupe.width,lH=els.loupe.height; loupeCtx.clearRect(0,0,lW,lH);
  loupeCtx.fillStyle="#f8fafc"; loupeCtx.fillRect(0,0,lW,lH);
  const cx=sx+sw/2, cy=sy+sh/2; const zoom=3;
  const srcW=Math.max(1,Math.round(lW/zoom)), srcH=Math.max(1,Math.round(lH/zoom));
  const sxx=Math.max(0,Math.min(Math.round(cx-srcW/2), cropImg.width-srcW));
  const syy=Math.max(0,Math.min(Math.round(cy-srcH/2), cropImg.height-srcH));
  loupeCtx.imageSmoothingEnabled=false;
  loupeCtx.drawImage(cropImg, sxx,syy,srcW,srcH, 0,0, lW,lH);
  // Bead
  drawBeadSim();
}
function srgbToLin(c){ c/=255; return c<=0.04045?c/12.92:Math.pow((c+0.055)/1.055,2.4); }
function rgbToXyz(r,g,b){ r=srgbToLin(r); g=srgbToLin(g); b=srgbToLin(b); const x=r*0.4124+g*0.3576+b*0.1805, y=r*0.2126+g*0.7152+b*0.0722, z=r*0.0193+g*0.1192+b*0.9505; return [x,y,z]; }
function xyzToLab(x,y,z){ const xr=x/0.95047, yr=y/1, zr=z/1.08883; const f=t=> t>0.008856?Math.pow(t,1/3):(7.787*t+16/116); const fx=f(xr),fy=f(yr),fz=f(zr); return [116*fy-16, 500*(fx-fy), 200*(fy-fz)]; }
function rgbToLab(r,g,b){ const [x,y,z]=rgbToXyz(r,g,b); return xyzToLab(x,y,z); }
function deltaE(a,b){ const dL=a[0]-b[0], dA=a[1]-b[1], dB=a[2]-b[2]; return Math.sqrt(dL*dL+dA*dA+dB*dB); }
const labCache=new Map(); function cachedHexToLab(hex){ if(labCache.has(hex)) return labCache.get(hex); const m=/^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex)||[]; const r=parseInt(m[1]||'cc',16), g=parseInt(m[2]||'cc',16), b=parseInt(m[3]||'cc',16); const lab=rgbToLab(r,g,b); labCache.set(hex,lab); return lab; }
const delicaFallback=[ "#FFFFFF","#000000","#F2C100","#204B9B","#5DBB74","#6D4C41" ];
function drawBeadSim(){
  if(!cropImg) return;
  const W=els.beadSim.width,H=els.beadSim.height;
  const {sx,sy,sw,sh}=cropRegion();
  beadSimCtx.clearRect(0,0,W,H); beadSimCtx.fillStyle="#ffffff"; beadSimCtx.fillRect(0,0,W,H);
  const targetW=50, targetH=Math.max(8,Math.round(targetW*(sh/sw)));
  const t=document.createElement('canvas'); t.width=targetW; t.height=targetH;
  const tc=t.getContext('2d'); tc.drawImage(cropImg, sx,sy,sw,sh, 0,0, targetW, targetH);
  const data=tc.getImageData(0,0,targetW,targetH).data;
  const beads = delicaFallback.map(h=>({hex:h, lab:cachedHexToLab(h)}));
  function nearestHex(r,g,b){ const lab=rgbToLab(r,g,b); let best=beads[0].hex, bestD=1e9; for(const bd of beads){ const d=deltaE(lab,bd.lab); if(d<bestD){ bestD=d; best=bd.hex; } } return best; }
  const cellPx=Math.min(10, Math.max(4, Math.floor(Math.min(W/targetW,H/targetH))));
  const ox=Math.floor((W-cellPx*targetW)/2), oy=Math.floor((H-cellPx*targetH)/2);
  for(let y=0;y<targetH;y++){ for(let x=0;x<targetW;x++){ const idx=(y*targetW+x)*4; const rr=data[idx],gg=data[idx+1],bb=data[idx+2]; const hex=nearestHex(rr,gg,bb); const px=ox+x*cellPx, py=oy+y*cellPx; beadSimCtx.fillStyle=hex; beadSimCtx.fillRect(px+1,py+1,cellPx-2,cellPx-2); beadSimCtx.strokeStyle="#00000022"; beadSimCtx.strokeRect(px+0.5,py+0.5,cellPx-1,cellPx-1); } }
  markDraw('bead', true);
}

// ---- Interactions ----
function resetCrop(){
  if(!cropImg) return;
  const s=Math.min(els.cropCanvas.width/cropImg.width, els.cropCanvas.height/cropImg.height);
  const vw=cropImg.width*s, vh=cropImg.height*s;
  const offX=Math.floor((els.cropCanvas.width - vw)/2), offY=Math.floor((els.cropCanvas.height - vh)/2);
  const w=Math.floor(vw*0.7), h=Math.floor(vh*0.7);
  crop = {x: offX + Math.floor((vw - w)/2), y: offY + Math.floor((vh - h)/2), w, h};
  drawCropper();
}
function loadIntoCropper(img){
  cropImg=img; setImage(img);
  resetCrop();
  const bw=Math.max(1,parseInt(document.getElementById('beadW').value||'90',10));
  const bh=Math.max(1,parseInt(document.getElementById('beadH').value||'50',10));
  document.getElementById('cropAspectLabel').textContent = "Aspect locked to "+bw+":"+bh+" beads";
  drawCropper();
}
els.btnResetCrop.addEventListener('click', resetCrop);

let dragMode=null,isDragging=false,dragOX=0,dragOY=0;
els.cropCanvas.addEventListener('pointerdown', (e)=>{
  const {mx,my}=getCanvasPos(e);
  const handle=hitHandle(mx,my);
  const inside=(mx>crop.x && mx<crop.x+crop.w && my>crop.y && my<crop.y+crop.h);
  if(!handle && !inside) return;
  e.preventDefault(); try{ els.cropCanvas.setPointerCapture(e.pointerId); }catch(_){}
  dragMode = handle ? handle : 'move'; isDragging=true; dragOX=mx; dragOY=my;
});
window.addEventListener('pointermove', (e)=>{
  const {mx,my}=getCanvasPos(e); lastPointer={mx,my}; setTouch(mx,my);
  if(isDragging){ const dx=mx-dragOX, dy=my-dragOY; dragOX=mx; dragOY=my;
    if (dragMode==='move'){ crop.x+=dx; crop.y+=dy; }
    else {
      if (dragMode.includes('n')){ crop.y+=dy; crop.h-=dy; }
      if (dragMode.includes('s')){ crop.h+=dy; }
      if (dragMode.includes('w')){ crop.x+=dx; crop.w-=dx; }
      if (dragMode.includes('e')){ crop.w+=dx; }
    }
    if (document.getElementById('lockCropAspect').checked){
      const bw=parseInt(document.getElementById('beadW').value,10)||90;
      const bh=parseInt(document.getElementById('beadH').value,10)||50;
      const ar=bw/bh;
      if (crop.w/crop.h>ar){ crop.w=Math.round(crop.h*ar); } else { crop.h=Math.round(crop.w/ar); }
    }
    crop.w=Math.max(20, Math.min(crop.w, els.cropCanvas.width - crop.x));
    crop.h=Math.max(20, Math.min(crop.h, els.cropCanvas.height - crop.y));
    crop.x=Math.max(0, Math.min(crop.x, els.cropCanvas.width - crop.w));
    crop.y=Math.max(0, Math.min(crop.y, els.cropCanvas.height - crop.h));
    drawCropper();
  } else { drawCropper(); }
});
window.addEventListener('pointerup', ()=>{ isDragging=false; });
window.addEventListener('pointercancel', ()=>{ isDragging=false; });

// File load
els.file.addEventListener('change', async (e)=>{
  const f=e.target.files && e.target.files[0];
  if(!f){ logStatus("No file chosen."); return; }
  setFile(f);
  try{
    const out = await robustLoadFile(f);
    const img = out.img, url = out.url;
    sourceImg=img; if (els.origPreview){ els.origPreview.src=url; markDraw('orig',true); }
    loadIntoCropper(sourceImg); drawBeadSim(); logStatus("Image loaded.");
  }catch(err){
    logStatus("Failed to load image: "+err.message);
    alert("Load failed. If this is HEIC, use a screenshot (PNG) or export JPEG.");
  }
});

// Test image
document.getElementById('btnLoadTest').addEventListener('click', async ()=>{
  try{
    logStatus("Loading test image...");
    const img=await loadImage("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAGZJREFUeNrs1zENgDAMQ9GJ//+S0Q8iS6y2zQ8xwEwqg1cBGf1mGboD1z4iQe6gqv2QwMDAwMDAwMDwHhU9m7HkqKqKqKqKqPZl8YwMDAwMDAwMDwFhtc2v1HcXz3CwMDAwMDAwMPC6tQ8AAQYAVFQxA7X1mMcAAAAASUVORK5CYII=");
    sourceImg=img; if(els.origPreview){ els.origPreview.src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAGZJREFUeNrs1zENgDAMQ9GJ//+S0Q8iS6y2zQ8xwEwqg1cBGf1mGboD1z4iQe6gqv2QwMDAwMDAwMDwHhU9m7HkqKqKqKqKqPZl8YwMDAwMDAwMDwFhtc2v1HcXz3CwMDAwMDAwMPC6tQ8AAQYAVFQxA7X1mMcAAAAASUVORK5CYII="; markDraw('orig',true); }
    loadIntoCropper(sourceImg); drawBeadSim(); logStatus("Test image loaded.");
  }catch(err){ logStatus("Test image failed: "+err.message); }
});

// First draw
drawCropper();
</script>
</body>
</html>
