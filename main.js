
// v3.6.3 iOS-safe
const TEST_DATA_URL = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAGZJREFUeNrs1zENgDAMQ9GJ//+S0Q8iS6y2zQ8xwEwqg1cBGf1mGboD1z4iQe6gqv2QwMDAwMDAwMDwHhU9m7HkqKqKqKqKqPZl8YwMDAwMDAwMDwFhtc2v1HcXz3CwMDAwMDAwMPC6tQ8AAQYAVFQxA7X1mMcAAAAASUVORK5CYII=";
const statusEl = document.getElementById('statusLog');
function logStatus(msg){ const t=new Date().toLocaleTimeString(); statusEl.textContent += "\n["+t+"] "+msg; }
window.addEventListener('error', e=>{ logStatus("JS error: "+(e.message||e.error)); });
window.addEventListener('unhandledrejection', e=>{ logStatus("Promise rejection: "+(e.reason&&e.reason.message?e.reason.message:e.reason)); });

const debugEl = document.getElementById('debugOut');
const copyBtn = document.getElementById('btnCopyDebug');
let debugState = { loader:'—', file:{name:'—',type:'—',size:0}, image:{w:0,h:0,ar:0}, drew:{orig:false,crop:false,bead:false}, device:{dpr:window.devicePixelRatio||1, ua:navigator.userAgent} };
function upd(){ const f=debugState.file,i=debugState.image; const sz=f.size?(f.size>=1e6?(f.size/1e6).toFixed(2)+' MB':(f.size/1e3).toFixed(1)+' KB'):'0';
  debugEl.textContent = ["Loader: "+debugState.loader,"File: "+f.name+" ("+f.type+", "+sz+")","Image: "+i.w+"×"+i.h+" (AR "+(i.ar||0).toFixed(3)+")","Drawn → Original:"+(debugState.drew.orig?'✅':'—')+"  Crop:"+(debugState.drew.crop?'✅':'—')+"  Bead:"+(debugState.drew.bead?'✅':'—'),"dpr: "+debugState.device.dpr,"UA: "+debugState.device.ua].join("\n"); }
function setLoader(x){ debugState.loader=x; upd(); }
function setFile(f){ if(!f) return; debugState.file={name:f.name||'—',type:f.type||'—',size:f.size||0}; upd(); }
function setImage(img){ if(!img) return; debugState.image={w:img.width||0,h:img.height||0,ar: img.width?img.width/img.height:0}; upd(); }
function markDrew(k,v){ debugState.drew[k]=!!v; upd(); }
upd(); copyBtn.addEventListener('click', ()=>{ const r=document.createRange(); r.selectNodeContents(debugEl); const s=window.getSelection(); s.removeAllRanges(); s.addRange(r); document.execCommand('copy'); });

const els = { file:document.getElementById('file'), btnLoadTest:document.getElementById('btnLoadTest'), btnResetCrop:document.getElementById('btnResetCrop'),
  lockCropAspect:document.getElementById('lockCropAspect'), cropAspectLabel:document.getElementById('cropAspectLabel'), beadW:document.getElementById('beadW'), beadH:document.getElementById('beadH'),
  origPreview:document.getElementById('origPreview'), fileInfo:document.getElementById('fileInfo'),
  cropThumb:document.getElementById('cropThumb'), loupe:document.getElementById('loupe'), beadSim:document.getElementById('beadSim'), cropCanvas:document.getElementById('cropCanvas')};
const cropCtx = els.cropCanvas.getContext('2d', {willReadFrequently:true});
const cropThumbCtx = els.cropThumb.getContext('2d', {willReadFrequently:true});
const loupeCtx = els.loupe.getContext('2d', {willReadFrequently:true});
const beadSimCtx = els.beadSim.getContext('2d', {willReadFrequently:true});

function loadImage(url){ return new Promise((res,rej)=>{ const img=new Image(); img.onload=()=>res(img); img.onerror=()=>rej(new Error('Image load failed')); img.src=url; }); }
function isIOS(){ return /iPad|iPhone|iPod/.test(navigator.userAgent) || (navigator.platform==='MacIntel' && navigator.maxTouchPoints>1); }
async function robustLoadFile(file){ if(!file) throw new Error('No file'); try{ logStatus('Loader: FileReader'); const dataURL=await new Promise((res,rej)=>{ const r=new FileReader(); r.onload=()=>res(r.result); r.onerror=()=>rej(new Error('FileReader failed')); r.readAsDataURL(file); }); const img=await loadImage(dataURL); return {img,url:dataURL,via:'FileReader'}; }catch(e){ logStatus('FileReader failed '+e.message); }
  try{ logStatus('Loader: BlobURL'); const blobURL=URL.createObjectURL(file); const img=await loadImage(blobURL); return {img,url:blobURL,via:'BlobURL'}; }catch(e){ logStatus('BlobURL failed '+e.message); }
  if(!isIOS() && 'createImageBitmap' in window){ try{ logStatus('Loader: createImageBitmap'); const bmp=await createImageBitmap(file); const can=document.createElement('canvas'); const maxDim=2400; const sc=Math.min(1,maxDim/Math.max(bmp.width,bmp.height)); can.width=Math.max(1,Math.round(bmp.width*sc)); can.height=Math.max(1,Math.round(bmp.height*sc)); const c=can.getContext('2d'); c.drawImage(bmp,0,0,can.width,can.height); const dataURL=can.toDataURL('image/jpeg',0.92); const img=await loadImage(dataURL); return {img,url:dataURL,via:'createImageBitmap'}; }catch(e){ logStatus('createImageBitmap failed '+e.message); } }
  throw new Error('All loaders failed');
}

let sourceImg=null, cropImg=null, viewScale=1; let crop={x:80,y:40,w:440,h:280}; let isDragging=false, dragMode=null, dragOX=0, dragOY=0;
function getCanvasPos(e){ const rect=els.cropCanvas.getBoundingClientRect(); const sx=els.cropCanvas.width/rect.width; const sy=els.cropCanvas.height/rect.height; const mx=(e.clientX-rect.left)*sx; const my=(e.clientY-rect.top)*sy; return {mx,my}; }
function handlePoints(){ const midX=crop.x+crop.w/2, midY=crop.y+crop.h/2; return [{name:'nw',x:crop.x,y:crop.y},{name:'ne',x:crop.x+crop.w,y:crop.y},{name:'sw',x:crop.x,y:crop.y+crop.h},{name:'se',x:crop.x+crop.w,y:crop.y+crop.h},{name:'n',x:midX,y:crop.y},{name:'s',x:midX,y:crop.y+crop.h},{name:'w',x:crop.x,y:midY},{name:'e',x:crop.x+crop.w,y:midY}]; }
function hitHandle(mx,my){ const r=24,b=22; const cs=[{n:'nw',x:crop.x,y:crop.y},{n:'ne',x:crop.x+crop.w,y:crop.y},{n:'sw',x:crop.x,y:crop.y+crop.h},{n:'se',x:crop.x+crop.w,y:crop.y+crop.h}]; for(const c of cs){ const dx=mx-c.x,dy=my-c.y; if(dx*dx+dy*dy<=r*r) return c.n; } if(my>=crop.y+b && my<=crop.y+crop.h-b){ if(Math.abs(mx-crop.x)<=b) return 'w'; if(Math.abs(mx-(crop.x+crop.w))<=b) return 'e'; } if(mx>=crop.x+b && mx<=crop.x+crop.w-b){ if(Math.abs(my-crop.y)<=b) return 'n'; if(Math.abs(my-(crop.y+crop.h))<=b) return 's'; } return null; }
function drawCropper(){ const ctx=cropCtx; ctx.clearRect(0,0,els.cropCanvas.width,els.cropCanvas.height); if(!cropImg) return; const s=Math.min(els.cropCanvas.width/cropImg.width, els.cropCanvas.height/cropImg.height); viewScale=s; const vw=cropImg.width*s, vh=cropImg.height*s; const offX=Math.floor((els.cropCanvas.width - vw)/2), offY=Math.floor((els.cropCanvas.height - vh)/2); els.cropCanvas._offX=offX; els.cropCanvas._offY=offY; ctx.drawImage(cropImg,0,0,cropImg.width,cropImg.height, offX,offY, vw,vh); ctx.save(); ctx.fillStyle="rgba(0,0,0,0.35)"; ctx.beginPath(); ctx.rect(0,0,els.cropCanvas.width,els.cropCanvas.height); ctx.rect(crop.x,crop.y,crop.w,crop.h); ctx.fill("evenodd"); ctx.restore(); ctx.strokeStyle="#22c55e"; ctx.lineWidth=2; ctx.strokeRect(crop.x+0.5,crop.y+0.5,crop.w,crop.h); const hs=handlePoints(); ctx.fillStyle="#22c55e"; hs.forEach(p=>{ ctx.beginPath(); ctx.arc(p.x,p.y,9,0,Math.PI*2); ctx.fill(); ctx.strokeStyle="#15803d"; ctx.stroke(); }); updateCropThumb(); markDrew('crop',true); }
function cropRegion(){ const offX=els.cropCanvas._offX||0, offY=els.cropCanvas._offY||0; const sx=Math.max(0,Math.round((crop.x-offX)/viewScale)); const sy=Math.max(0,Math.round((crop.y-offY)/viewScale)); const sw=Math.max(1,Math.round(crop.w/viewScale)); const sh=Math.max(1,Math.round(crop.h/viewScale)); return {sx,sy,sw,sh}; }
function updateCropThumb(){ if(!cropImg) return; const {sx,sy,sw,sh}=cropRegion(); const tw=els.cropThumb.width, th=els.cropThumb.height; cropThumbCtx.clearRect(0,0,tw,th); cropThumbCtx.fillStyle="#f8fafc"; cropThumbCtx.fillRect(0,0,tw,th); const sc=Math.min(tw/sw,th/sh); const dw=Math.max(1,Math.round(sw*sc)), dh=Math.max(1,Math.round(sh*sc)); const dx=Math.floor((tw-dw)/2), dy=Math.floor((th-dh)/2); cropThumbCtx.drawImage(cropImg,sx,sy,sw,sh,dx,dy,dw,dh); const lW=els.loupe.width,lH=els.loupe.height; loupeCtx.clearRect(0,0,lW,lH); loupeCtx.fillStyle="#f8fafc"; loupeCtx.fillRect(0,0,lW,lH); const cx=sx+sw/2, cy=sy+sh/2; const zoom=3; const srcW=Math.max(1,Math.round(lW/zoom)), srcH=Math.max(1,Math.round(lH/zoom)); const sxx=Math.max(0,Math.min(Math.round(cx-srcW/2), cropImg.width-srcW)); const syy=Math.max(0,Math.min(Math.round(cy-srcH/2), cropImg.height-srcH)); loupeCtx.imageSmoothingEnabled=false; loupeCtx.drawImage(cropImg,sxx,syy,srcW,srcH,0,0,lW,lH); drawBeadSim(); }
function srgbToLin(c){ c/=255; return c<=0.04045?c/12.92:Math.pow((c+0.055)/1.055,2.4); } function rgbToXyz(r,g,b){ r=srgbToLin(r); g=srgbToLin(g); b=srgbToLin(b); const x=r*0.4124+g*0.3576+b*0.1805, y=r*0.2126+g*0.7152+b*0.0722, z=r*0.0193+g*0.1192+b*0.9505; return [x,y,z]; } function xyzToLab(x,y,z){ const xr=x/0.95047, yr=y/1, zr=z/1.08883; const f=t=> t>0.008856?Math.pow(t,1/3):(7.787*t+16/116); const fx=f(xr),fy=f(yr),fz=f(zr); return [116*fy-16, 500*(fx-fy), 200*(fy-fz)]; } function rgbToLab(r,g,b){ const [x,y,z]=rgbToXyz(r,g,b); return xyzToLab(x,y,z); } function deltaE(a,b){ const dL=a[0]-b[0], dA=a[1]-b[1], dB=a[2]-b[2]; return Math.sqrt(dL*dL+dA*dA+dB*dB); } const labCache=new Map(); function cachedHexToLab(hex){ if(labCache.has(hex)) return labCache.get(hex); const m=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex)||[]; const r=parseInt(m[1]||'cc',16), g=parseInt(m[2]||'cc',16), b=parseInt(m[3]||'cc',16); const lab=rgbToLab(r,g,b); labCache.set(hex,lab); return lab; } const delicaFallback=["#FFFFFF","#000000","#F2C100","#204B9B","#5DBB74","#6D4C41"];
function drawBeadSim(){ if(!cropImg) return; const W=els.beadSim.width,H=els.beadSim.height; const {sx,sy,sw,sh}=cropRegion(); beadSimCtx.clearRect(0,0,W,H); beadSimCtx.fillStyle="#ffffff"; beadSimCtx.fillRect(0,0,W,H); const targetW=50, targetH=Math.max(8,Math.round(targetW*(sh/sw))); const t=document.createElement('canvas'); t.width=targetW; t.height=targetH; const tc=t.getContext('2d'); tc.drawImage(cropImg, sx,sy,sw,sh, 0,0, targetW, targetH); const data=tc.getImageData(0,0,targetW,targetH).data; const beads=delicaFallback.map(h=>({hex:h,lab:cachedHexToLab(h)})); function nearestHex(r,g,b){ const lab=rgbToLab(r,g,b); let best=beads[0].hex, bestD=1e9; for(const bd of beads){ const d=deltaE(lab,bd.lab); if(d<bestD){ bestD=d; best=bd.hex; } } return best; } const cellPx=Math.min(10, Math.max(4, Math.floor(Math.min(W/targetW,H/targetH)))); const ox=Math.floor((W-cellPx*targetW)/2), oy=Math.floor((H-cellPx*targetH)/2); for(let y=0;y<targetH;y++){ for(let x=0;x<targetW;x++){ const idx=(y*targetW+x)*4; const rr=data[idx],gg=data[idx+1],bb=data[idx+2]; const hex=nearestHex(rr,gg,bb); const px=ox+x*cellPx, py=oy+y*cellPx; beadSimCtx.fillStyle=hex; beadSimCtx.fillRect(px+1,py+1,cellPx-2,cellPx-2); beadSimCtx.strokeStyle="#00000022"; beadSimCtx.strokeRect(px+0.5,py+0.5,cellPx-1,cellPx-1); } } markDrew('bead',true); }

function resetCrop(){ if(!cropImg) return; const s=Math.min(els.cropCanvas.width/cropImg.width, els.cropCanvas.height/cropImg.height); const vw=cropImg.width*s, vh=cropImg.height*s; const offX=Math.floor((els.cropCanvas.width - vw)/2), offY=Math.floor((els.cropCanvas.height - vh)/2); const w=Math.floor(vw*0.7), h=Math.floor(vh*0.7); crop={x: offX + Math.floor((vw - w)/2), y: offY + Math.floor((vh - h)/2), w, h}; drawCropper(); }
function loadIntoCropper(img){ cropImg=img; setImage(img); resetCrop(); const bw=Math.max(1,parseInt(document.getElementById('beadW').value||'90',10)); const bh=Math.max(1,parseInt(document.getElementById('beadH').value||'50',10)); document.getElementById('cropAspectLabel').textContent = "Aspect locked to "+bw+":"+bh+" beads"; drawCropper(); }
els.btnResetCrop.addEventListener('click', resetCrop);

let dragMode=null, isDragging=false, dragOX=0, dragOY=0;
els.cropCanvas.addEventListener('pointerdown', (e)=>{ const {mx,my}=getCanvasPos(e); const handle=hitHandle(mx,my); const inside=(mx>crop.x && mx<crop.x+crop.w && my>crop.y && my<crop.y+crop.h); if(!handle && !inside) return; e.preventDefault(); try{ els.cropCanvas.setPointerCapture(e.pointerId); }catch(_){ } dragMode = handle ? handle : 'move'; isDragging=true; dragOX=mx; dragOY=my; });
window.addEventListener('pointermove', (e)=>{ const {mx,my}=getCanvasPos(e); if(isDragging){ const dx=mx-dragOX, dy=my-dragOY; dragOX=mx; dragOY=my; if (dragMode==='move'){ crop.x+=dx; crop.y+=dy; } else { if (dragMode.includes('n')){ crop.y+=dy; crop.h-=dy; } if (dragMode.includes('s')){ crop.h+=dy; } if (dragMode.includes('w')){ crop.x+=dx; crop.w-=dx; } if (dragMode.includes('e')){ crop.w+=dx; } } if (document.getElementById('lockCropAspect').checked){ const bw=parseInt(document.getElementById('beadW').value,10)||90; const bh=parseInt(document.getElementById('beadH').value,10)||50; const ar=bw/bh; if (crop.w/crop.h>ar){ crop.w=Math.round(crop.h*ar); } else { crop.h=Math.round(crop.w/ar); } } crop.w=Math.max(20, Math.min(crop.w, els.cropCanvas.width - crop.x)); crop.h=Math.max(20, Math.min(crop.h, els.cropCanvas.height - crop.y)); crop.x=Math.max(0, Math.min(crop.x, els.cropCanvas.width - crop.w)); crop.y=Math.max(0, Math.min(crop.y, els.cropCanvas.height - crop.h)); drawCropper(); } else { drawCropper(); }});
window.addEventListener('pointerup', ()=>{ isDragging=false; }); window.addEventListener('pointercancel', ()=>{ isDragging=false; });

async function showImage(img, url){ if (img.decode) { try { await img.decode(); } catch(_){} } if (els.origPreview) { els.origPreview.src = url; markDrew('orig', true); } loadIntoCropper(img); drawBeadSim(); logStatus('Rendered: original → crop → bead'); }
els.file.addEventListener('change', async (e)=>{ const f=e.target.files && e.target.files[0]; if(!f) return; setFile(f); try{ const out=await robustLoadFile(f); setLoader(out.via); await showImage(out.img, out.url); }catch(err){ logStatus('Failed to load: '+err.message); alert('Load failed. If this is HEIC/HEIF, screenshot to PNG or export as JPEG.'); }});
els.btnLoadTest.addEventListener('click', async ()=>{ logStatus('Loading test image…'); const img=await loadImage(TEST_DATA_URL); await showImage(img, TEST_DATA_URL); });
